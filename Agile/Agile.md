# Agile

## The old ways: Waterfall
Anytime a project (any project) gets started, there is a key question that needs to be asked: can I got back? This might seem like a silly question, but there are some fields/projects where the answer to this question is actually no: a bridge builder, if a mistake is made with the bridge, can't just click "ctr + z" to undo the mistake. If a brain surgon accidentally cuts the wrong part of the brain, he can't just glue it back on witout consequence. There are times when work needs to be done and it needs to be done right the first time because there is little to no room for error. This is not a bad thing in itself, but it does limit how you can approach problems when this "waterfall" mindset is used. This is the methodology that used to be prevelant in the software world.

Pros to the Waterfall methodology:
- it is very easy to know what the end goal is
    - usually the end goal is explicitly spelled out in some sort of contract
- it is very easy to know what the "next" step is
- helps to reduce confusion between teams
    - each team will usually have a specific role in the development process, no need to second guess yourself and the part of the process you are working in
- you don't need any in-depth knowledge of any sort of "ceremonies" or mindsets to do your job well in a Waterfall environment: once step A is finished, you move on to step B, then C, etc.

Drawbacks to the Waterfall methodology:
- if a client agrees to contract/terms, but later realizes that they don't actually want those features they agreed to, they are stuck
    - on the flip side, the developers can't go back and revise things with the client in order to better produce what the client wants
- the lack of "backwards" movement creates a lot of pressure to "get it right" the first time. This can be problematic if teams are all doing isolated jobs and don't necessarily know how the pieces work together
- debugging is hard to do until the complete project is finished, and the end of the waterfall is reached. Because there is no backwards movement, any bugs discovered during the development process have to be worked around, since there is no backwards movement